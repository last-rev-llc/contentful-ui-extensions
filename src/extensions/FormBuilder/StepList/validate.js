/* eslint-disable no-unused-vars */

import { flatten, filter, identity, isEmpty, map, negate, pipe } from 'lodash';
import { indexBy, prop, merge } from 'lodash/fp';

/** Types of error that can be generated by this validator */
const errors = {
  CONFLICT_NAME: 'NAME_CONFLICT',
  UNDEFINED_NAME: 'NAME_UNDEFINED',
  UNDEFINED_TYPE: 'UNDEFINED_TYPE'
};

/** Levels for each type of error above, allows later filtering of levels */
const errorTypes = {
  CONFLICT_NAME: 'WARN',
  UNDEFINED_NAME: 'ERROR',
  UNDEFINED_TYPE: 'ERROR'
};

/**
 * Validate a single field by missing or incorrect properties
 * */
function validateField(field) {
  const toReturn = [];

  if (!field.name) {
    toReturn.push({ type: errors.UNDEFINED_NAME, id: field.id });
  }

  if (!field.type) {
    toReturn.push({ type: errors.UNDEFINED_TYPE, id: field.id });
  }

  return toReturn.filter(identity);
}

/**
 * Validate multiple fields based on default
 * criteria such as missing or incorrect fields
 * */
function validateFields(fields) {
  return fields.map((field) => validateField(field));
}

/**
 * Return the number of fields which use the same
 * name between all of the steps
 *
 * { [field.name]: { count, ids: [...] } }
 * */
function getFieldNameCounts(steps) {
  const allFields = steps.reduce((acc, { id, fields = [] }) => acc.concat(fields), []);

  const fieldNames = [];

  allFields.map(({ id, name }) => {
    if (!fieldNames[name]) {
      fieldNames[name] = {
        count: 0,
        ids: [id]
      };
    }

    fieldNames[name].count += 1;
  });

  return fieldNames;
}

/**
 * Each field should have a unique name
 * In some cases this may not be true, as names
 * can be duplicated between steps
 * */
function validateFieldNames(steps) {
  const fieldNameCounts = getFieldNameCounts(steps);

  return Object.entries(fieldNameCounts)
    .filter(([name, { count }]) => count > 1)
    .map(([name, { ids }]) => ids.map((id) => ({ type: errors.CONFLICT_NAME, id, name })));
}

/** Index an array of objects into an object of id => item */
const idIndexer = indexBy(prop('id'));

/**
 * Pass me an array of steps and I'll give you
 * back an object of `fieldId` => error
 * */
export function validateSteps(steps) {
  const toReturn = steps
    .map((step) => {
      const { fields = [] } = step;
      return validateFields(fields);
    })
    .concat(validateFieldNames(steps));

  return pipe(
    // Flatten to a single array
    flatten,

    // Remove all empty values
    filter(negate(isEmpty)),

    // Add error levels to each item, these levels can then be used to later
    // filter errors or warnings specifically
    map((error) => merge({ level: errorTypes[error.type] }, error)),

    // Transform from array of objects to object of indexed { [id]: object }
    idIndexer
  )(toReturn);
}

export default { validateSteps };
